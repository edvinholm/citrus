


!!!
We can read the whole packet in, and put it in a buffer where we always put the last
received packet in.
Then, we can interpret that data like Read(u64, id) etc.
And if there are strings, we set str.length to first 4 bytes, and then data to the next byte after that.
No need to allocate every string.
(Why did I not think of this before? Because I'm stupid.)


get_next_ucb_packet();


// Do one of these for every implementation of a User Client
room_server_user_client_loop()
{
	while(true)
	{
		UCB_Packet packet;
		if(get_next_ucb_packet(&packet)) {
			switch(packet.type) {

			}
		}
	}
}

// And then we have:
get_next_rcb_packet();

// And other stuff like
connect_to_user_server(User_ID user, Socket *_socket);
disconnect_from_user_server(Socket *socket);

perform_user_server_transaction(USB_Transaction transaction, Socket *socket);
// etc.




enum RCB_Packet_Type
{
	ROOM_INIT
}

struct Packet_Header
{
	u64 payload_size;
};

// So reading a UCB_TRANSACTION_VOTE packet will be like:
	read_packet_header:
		u64 -> payload_size;
	read_bytes:payload_size -> buffer.
	read_ucb_packet_type:
		buffer -> u16 -> type;
	read_ucb_payload:
		buffer -> u8  -> commit;
		buffer -> s32 -> comment.length;
		comment.data = buffer_at;
		skip bytes: comment.length;
	ensure_at_end of buffer.

struct UCB_Transaction_Vote_Payload
{
	bool commit;
	String comment;
};

struct UCB_Packet
{
	UCB_Packet_Type type;
	union {
		UCB_Transaction_Vote_Payload transaction_vote;
	}
}

struct Packet
{
	Packet_Header header;
	union {
		RSB_Packet rsb;
		RCB_Packet rcb;
		USB_Packet usb;
		UCB_Packet ucb;
	};	
}





